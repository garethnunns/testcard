<html>
	<head>
		<title>Test Card</title>

		<style>
		html,body {
			margin: 0;
			padding: 0;
		}

		canvas {
			width: 100%;
		}
		</style>
	</head>

	<body>
		<canvas></canvas>

		<script type="text/javascript">
class Card {
	constructor(ctx, options = null) {
		this.ctx = ctx
		
		if(options == null)
			options = {
				width: 1920,
				height: 1080,
				fps: 25,
				colors: {
					bg: '#000000',
					fg: '#ffffff',
					accent: '#ffcc00'
				}
			}
		
		this.options = options
			
		this.options.margins = {
			h: options.width / 15,
			v: options.height / 10,
		}

		this.ctx.canvas.width  = options.width
		this.ctx.canvas.height = options.height

		this.render = this.render.bind(this)

		this._frame = 0

		// duration in frames
		this.duration = 2 * this.options.fps + 3

		this.render()
	}

	get frame() {
		return this._frame
	}

	set frame(frame) {
		if (frame >= this.duration)
			this._frame = 0
		else
			this._frame = frame
	}

	get frameOffset() {
		return this._frame - this.options.fps - 1
	}

	render() {
		const ctx = this.ctx

		ctx.save();
		ctx.fillStyle = this.options.colors.bg;
		ctx.fillRect(0,0,this.options.width,this.options.height);
		
		ctx.strokeStyle = this.options.colors.fg;
		ctx.fillStyle = this.options.colors.fg;
		ctx.textBaseline = "middle";
		ctx.lineCap = "round";


		// marks
		ctx.save();

		// line markers
		ctx.lineWidth = 2;
		ctx.strokeStyle = this.hexToRgba(this.options.colors.fg, 0.5)

		const markHeight = this.options.height / 10
		const markNum = this.duration - 1
		const markGap = Math.floor((this.options.width - 2 * this.options.margins.h) / markNum)

		const markLeft = Math.floor(this.options.width / 2 - ((this.options.fps + 0.5) * markGap))
		const markBottom = this.options.height - 2 * this.options.margins.v
		const markTop = markBottom - markHeight;

		for (var i=0; i < markNum; i++) {
			const left = markLeft + i * markGap
			ctx.beginPath();
			ctx.moveTo(left, markBottom - markHeight)
			ctx.lineTo(left, markBottom)
			ctx.stroke();
		}
		ctx.save();

		// triangles
		ctx.fillStyle = this.options.colors.accent;

		const triTop = markTop - this.options.height / 100
		const triBottom = markBottom + this.options.height / 100
		const triWidth = this.options.width / 20
		const triHeight = Math.min(this.options.height / 20,triWidth / 1.5)
		const triFontSize = triWidth/2.5

		var small = false;

		ctx.font = `${triFontSize}px Courier`
		ctx.textAlign = 'center'

		var offset = -1;

		const triNum = 4;

		for(var i = 0.5; i < (markNum - 1); i += (this.options.fps/triNum)) {
			const cent = markLeft + i * markGap
			const width = (1 - small * 0.5) * 0.5 * triWidth
			const height = (1 - small * 0.5) * triHeight

			// top triangles
			ctx.beginPath();
			ctx.moveTo(cent, triTop)
			ctx.lineTo(cent + width, triTop - height)
			ctx.lineTo(cent - width, triTop - height)
			ctx.closePath()
			ctx.fill()

			if(!small) ctx.fillText(offset * this.options.fps, cent, triTop - height - triFontSize/2)

			// bottom triangles
			ctx.beginPath();
			ctx.moveTo(cent, triBottom)
			ctx.lineTo(cent + width, triBottom + height)
			ctx.lineTo(cent - width, triBottom + height)
			ctx.closePath()
			ctx.fill()

			if(!small) ctx.fillText(offset, cent, triBottom + height + triFontSize/2)

			small = !small
			offset += 1/triNum
		}

		ctx.save();

		// end of constants in image

		ctx.restore();

		// frame marker
		if(Math.abs(this.frameOffset) <= this.options.fps) {
			const markerLeft = markLeft + ((this.frame - 1) * markGap)
			ctx.fillRect(markerLeft , markTop, markGap, markHeight)

			// circle counter
			ctx.lineWidth = 20
			ctx.strokeStyle = this.options.colors.accent
			ctx.fillStyle = this.options.colors.fg

			const circleRadius = Math.min(
				(this.options.width - 2 * this.options.margins.h) / 6,
				(this.options.height - 2 * this.options.margins.v) / 4
			)

			const circleCenter = {
				x: this.options.margins.h + circleRadius,
				y: this.options.margins.v * 3
			}

			const circleFontSize = circleRadius / 2
			ctx.font = `${circleFontSize}px Courier`

			const frameAngle = 0

			ctx.beginPath()
			ctx.arc(circleCenter.x, circleCenter.y, circleRadius,
				this.mapRange([0,this.options.fps],[-0.5,1.5],this.frameOffset) * Math.PI,
				this.mapRange([-this.options.fps,0],[-0.5,1.5],this.frameOffset) * Math.PI)
			ctx.stroke()

			if(this.frameOffset == 0) {
				ctx.fill()
			}

			ctx.fillStyle = this.options.colors.accent
			ctx.fillText(
				(this.frameOffset < 0 ? '-':'+') + this.zeroPad(Math.abs(this.frameOffset),this.options.fps.toString().length), 
				circleCenter.x, circleCenter.y)
		}

		this.frame++;
		setTimeout(this.render, (1000/this.options.fps)*1)
		return ctx;
	}

	hexToRgb(hex) {
		const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
		return result ? {
			r: parseInt(result[1], 16),
			g: parseInt(result[2], 16),
			b: parseInt(result[3], 16)
		} : null
	}

	hexToRgba(hex, a) {
		const rgb = this.hexToRgb(hex)
		return `rgba(${rgb.r},${rgb.g},${rgb.b},${a})`
	}

	mapRange (from, to, s) {
		return Math.max(to[0],Math.min(to[1],to[0] + (s - from[0]) * (to[1] - to[0]) / (from[1] - from[0])))
	}

	zeroPad(num, places) {
		var zero = places - num.toString().length + 1;
		return Array(+(zero > 0 && zero)).join("0") + num;
	}
}

const ctx = document.querySelector('canvas').getContext('2d')

var testCard = new Card(ctx);
		</script>
	</body>
</html>